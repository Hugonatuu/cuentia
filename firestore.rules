
/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for all user-related data,
 * which is consolidated under the /customers/{userId} collection. This includes
 * user profiles, generated content (stories, characters), and billing information.
 * Public read access is granted where appropriate (e.g., predefined characters, community stories).
 *
 * Data Structure:
 * - /customers/{userId}: Stores user profile information and all related subcollections.
 *   Only the authenticated user can manage their own data.
 * - /customers/{userId}/stories/{storyId}: Stores stories created by the user.
 * - /customers/{userId}/characters/{characterId}: Stores characters created by the user.
 * - /customers/{userId}/checkout_sessions/{sessionId}: Stores Stripe checkout sessions.
 * - /customers/{userId}/subscriptions/{subscriptionId}: Stores Stripe subscription data.
 * - /subscriptions/{subscriptionId}: Stores subscription plans. Read access is public.
 * - /predefinedCharacters/{characterId}: Stores predefined characters. Read access is public.
 * - /communityStories/{storyId}: Stores community stories. Read access is public.
 *
 * Key Security Decisions:
 * - Users can only read and write their own customer document and all its subcollections.
 * - Listing of customer documents is implicitly denied.
 * - Subscription plans, predefined characters, and community stories are
 *   publicly readable but not writable by end-users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure customer data, including profile, billing, and user-generated content.
     * @path /customers/{userId}
     */
    match /customers/{userId} {
        allow get: if isOwner(userId);
        allow create: if request.auth.uid == userId;
        allow update, delete: if isExistingOwner(userId);

        /**
        * @description Secure stories created by each user. Only the owner can manage their stories.
        * @path /customers/{userId}/stories/{storyId}
        */
        match /stories/{storyId} {
            allow get, list: if isOwner(userId);
            allow create: if isOwner(userId);
            allow update, delete: if isExistingOwner(userId);
        }

        /**
        * @description Secure characters created by each user. Only the owner can manage their characters.
        * @path /customers/{userId}/characters/{characterId}
        */
        match /characters/{characterId} {
            allow get, list: if isOwner(userId);
            allow create: if isOwner(userId);
            allow update, delete: if isExistingOwner(userId);
        }

        /**
        * @description Secure checkout sessions. Users can only create and read their own.
        * @path /customers/{userId}/checkout_sessions/{sessionId}
        */
        match /checkout_sessions/{sessionId} {
            allow create: if isOwner(userId);
            allow get: if isOwner(userId);
            allow list, update, delete: if false; // Only the Firebase extension should manage these.
        }
        
        /**
        * @description Secure subscriptions. Users can only read their own subscription data.
        * @path /customers/{userId}/subscriptions/{subscriptionId}
        */
        match /subscriptions/{subscriptionId} {
            allow get, list: if isOwner(userId);
            allow create, update, delete: if false; // Only the Firebase extension should manage these.
        }
        
        /**
        * @description Secure payments. Users can only read their own payment data.
        * @path /customers/{userId}/payments/{paymentId}
        */
        match /payments/{paymentId} {
            allow get, list: if isOwner(userId);
            allow create, update, delete: if false; // Only the Firebase extension should manage these.
        }
        
        /**
         * @description Allow the client to write payment receipts for transactional integrity.
         * @path /customers/{userId}/payments_applied/{paymentId}
         */
        match /payments_applied/{paymentId} {
            allow get, create: if isOwner(userId);
            allow list, update, delete: if false;
        }
    }

    /**
     * @description Subscription plans are publicly readable, but not writable by end-users.
     * @path /subscriptions/{subscriptionId}
     */
    match /subscriptions/{subscriptionId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Predefined characters are publicly readable, but not writable by end-users.
     * @path /predefinedCharacters/{characterId}
     */
    match /predefinedCharacters/{characterId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Community stories are publicly readable, but not writable by end-users.
     * @path /communityStories/{storyId}
     */
    match /communityStories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    //------------------- Helper functions -----------------------

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the request is made by the owner of the document.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @return {boolean} True if the request is made by the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the request is made by the existing owner of the document.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @return {boolean} True if the request is made by the existing owner, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}
